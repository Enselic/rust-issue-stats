use chrono::{DateTime, FixedOffset};
use clap::Parser;
use std::cell::RefCell;
use std::fmt::Display;
use std::io::Write;
use std::path::PathBuf;
use tracing_subscriber::FmtSubscriber;

use rust_issue_stats::*;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,

    /// To sanity check the conclusion of the program, the data that the program
    /// analyses is dumped into this file. One line per analyzed issue.
    #[arg(long, default_value = "target/rust-issue-stats/issues.data-dump.txt")]
    data_dump_path: PathBuf,
}

const SLOTS: i64 = 10;

#[derive(Default)]
struct Stats {
    analyzed_issues: usize,
    needs_mcve_issues: usize,
    needs_mcve_issues_resolved_after_weeks: [u64; SLOTS as usize],
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    // Enable like this: `RUST_LOG=rust_issue_stats=warn cargo run`
    tracing::subscriber::set_global_default(
        FmtSubscriber::builder()
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .finish(),
    )?;

    eprintln!("Writing data dump to {:?}", args.data_dump_path);
    std::fs::create_dir_all(args.data_dump_path.parent().unwrap())?;
    let data_dump_file = std::fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(&args.data_dump_path)?;

    let github = GitHub::new();

    let stats = RefCell::new(Stats::default());

    let variables = serde_json::json!({
        "page_size": args.page_size,
        "item_types": ["LABELED_EVENT", "UNLABELED_EVENT"],
    });
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let conclusion = analyze_issue(issue).unwrap();
                stats.borrow_mut().analyzed_issues += 1;
                if conclusion.ever_labeled_needs_mcve() {
                    stats.borrow_mut().needs_mcve_issues += 1;
                }
                if let Conclusion::NeedsMcveResolvedAfterWeeks(mut weeks) = conclusion {
                        if weeks >= SLOTS {
                            weeks = SLOTS - 1;
                        }
                        stats.borrow_mut().needs_mcve_issues_resolved_after_weeks[weeks as usize] += 1;
                }

                writeln!(&data_dump_file, "{issue} => {conclusion}").unwrap();
            },
            || {
                let stats = stats.borrow();
                println!(
                    "Number of issues analyzed:\x20{}\n\
                     \x20                 of these, {} was ever labeled `E-needs-mcve`\n\
                     \x20                 of these, {} was resolved (unlabeled or closed) within the first week.\n\
                     \x20                           {} was resolved within 2 weeks.\n\
                     \x20                           {} was resolved within 3 weeks.\n\
                     \x20                           {} was resolved within 4 weeks.\n\
                     \x20                           {} was resolved within 5 weeks.\n\
                     \x20                           {} was resolved within 6 weeks.\n\
                     \x20                           {} was resolved within 7 weeks.\n\
                     \x20                           {} was resolved within 8 weeks.\n\
                     \x20                           {} was resolved within 9 weeks.\n\
                     \x20                           {} was resolved within 10 weeks or longer.\n\
                    ",
                    stats.analyzed_issues,
                    stats.needs_mcve_issues,
                    stats.needs_mcve_issues_resolved_after_weeks[0],
                    stats.needs_mcve_issues_resolved_after_weeks[1],
                    stats.needs_mcve_issues_resolved_after_weeks[2],
                    stats.needs_mcve_issues_resolved_after_weeks[3],
                    stats.needs_mcve_issues_resolved_after_weeks[4],
                    stats.needs_mcve_issues_resolved_after_weeks[5],
                    stats.needs_mcve_issues_resolved_after_weeks[6],
                    stats.needs_mcve_issues_resolved_after_weeks[7],
                    stats.needs_mcve_issues_resolved_after_weeks[8],
                    stats.needs_mcve_issues_resolved_after_weeks[9],

                );
            },
        )
        .await;

    Ok(())
}

#[derive(PartialEq, PartialOrd, Ord, Eq, Debug)]
pub enum Conclusion {
    /// The issue never had the `E-needs-mcve` label.
    NeverLabeledNeedsMcve,

    /// Was labeled `E-needs-mcve` at the given date
    LabeledNeedsMcveAt(DateTime<FixedOffset>),

    /// The `E-needs-mcve` was resolved after the given number of weeks since it
    /// was added. "Resolved" means either that the label was removed or that
    /// the issue was closed.
    NeedsMcveResolvedAfterWeeks(i64),
}

pub fn analyze_issue(issue: &IssueWithTimelineItems) -> anyhow::Result<Conclusion> {
    let mut state = IssueState::NeverLabeledNeedsMcve;

    for timeline_item in &issue.timeline_items {
        match state {
            IssueState::NeverLabeledNeedsMcve => {
                if let TimelineItem::LabeledEvent { label, created_at } = timeline_item {
                    if *label == Label::NeedsMcve {
                        state = IssueState::LabeledNeedsMcveDate(*created_at);
                    }
                }
            }
            IssueState::LabeledNeedsMcveDate(date) => {
                let resolved =
                    if let TimelineItem::UnlabeledEvent { label, created_at } = timeline_item {
                        if *label == Label::NeedsMcve {
                            Some(created_at)
                        } else {
                            None
                        }
                    } else if let TimelineItem::ClosedEvent { created_at } = timeline_item {
                        Some(created_at)
                    } else {
                        None
                    };

                if let Some(resolved) = resolved {
                    let duration = resolved.signed_duration_since(date);
                    return Ok(Conclusion::NeedsMcveResolvedAfterWeeks(
                        duration.num_weeks(),
                    ));
                }
            }
        }
    }

    Ok(state.into_conclusion())
}

impl Conclusion {
    pub fn ever_labeled_needs_mcve(&self) -> bool {
        match self {
            Conclusion::NeverLabeledNeedsMcve => false,
            Conclusion::NeedsMcveResolvedAfterWeeks(_) => true,
            Conclusion::LabeledNeedsMcveAt(_) => true,
        }
    }
}

impl Display for Conclusion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Conclusion::NeverLabeledNeedsMcve => f.write_str("Never labeled E-needs-mcve"),
            Conclusion::LabeledNeedsMcveAt(date) => {
                write!(
                    f,
                    "Labeled E-needs-mcve at {} but never resolved",
                    date.format("%Y-%m-%d")
                )
            }
            Conclusion::NeedsMcveResolvedAfterWeeks(weeks) => {
                write!(f, "Resolved E-needs-mcve after {} weeks", weeks)
            }
        }
    }
}

enum IssueState {
    NeverLabeledNeedsMcve,
    LabeledNeedsMcveDate(DateTime<FixedOffset>),
}

impl IssueState {
    fn into_conclusion(self) -> Conclusion {
        match self {
            IssueState::NeverLabeledNeedsMcve => Conclusion::NeverLabeledNeedsMcve,
            IssueState::LabeledNeedsMcveDate(date) => Conclusion::LabeledNeedsMcveAt(date),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_not_applicable() {
        let issue = IssueWithTimelineItems {
            url: "N/A".to_string(),
            number: 42,
            title: "Never labeled E-needs-mcve".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![TimelineItem::LabeledEvent {
                label: Label::Other("foo".to_string()),
                created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            }],
        };

        assert_eq!(
            analyze_issue(&issue).unwrap(),
            Conclusion::NeverLabeledNeedsMcve
        )
    }

    #[test]
    fn test_never_resolved() {
        let issue = IssueWithTimelineItems {
            url: "N/A".to_string(),
            number: 42,
            title: "Labeled E-needs-mcve but never resolved".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![TimelineItem::LabeledEvent {
                label: Label::NeedsMcve,
                created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            }],
        };

        assert_eq!(
            analyze_issue(&issue).unwrap(),
            Conclusion::LabeledNeedsMcveAt(
                DateTime::parse_from_rfc3339("2020-01-01T00:00:00Z").unwrap()
            )
        );
    }

    #[test]
    fn test_resolved_via_unlabeling() {
        let issue = IssueWithTimelineItems {
            url: "N/A".to_string(),
            number: 42,
            title: "Labeled E-needs-mcve then unlabeled".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![
                TimelineItem::LabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
                },
                TimelineItem::UnlabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-08T00:00:00Z").unwrap(),
                },
            ],
        };

        assert_eq!(
            analyze_issue(&issue).unwrap(),
            Conclusion::NeedsMcveResolvedAfterWeeks(1)
        );
    }

    #[test]
    fn test_resolved_via_close() {
        let issue = IssueWithTimelineItems {
            url: "N/A".to_string(),
            number: 42,
            title: "Labeled E-needs-mcve but never resolved".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![
                TimelineItem::LabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
                },
                TimelineItem::ClosedEvent {
                    created_at: DateTime::from_str("2020-01-15T00:00:00Z").unwrap(),
                },
            ],
        };

        assert_eq!(
            analyze_issue(&issue).unwrap(),
            Conclusion::NeedsMcveResolvedAfterWeeks(2)
        );
    }
}
