use chrono::{DateTime, Duration, FixedOffset};
use clap::Parser;
use tracing_subscriber::FmtSubscriber;

use rust_issue_stats::*;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,

    #[arg(long, default_value = "12")]
    months_considered_old: i64,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    // Enable like this: `RUST_LOG=rust_issue_stats=warn cargo run`
    tracing::subscriber::set_global_default(
        FmtSubscriber::builder()
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .finish(),
    )?;

    let github = GitHub::new();

    let variables = serde_json::json!({
        "page_size": args.page_size,
        "states": ["OPEN"],
        "filterBy": {
            "labels": ["E-needs-mcve"]
        }
    });
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let months_old = get_e_needs_mcve_label_age(issue).unwrap().num_days() / 30;
                if months_old > args.months_considered_old {
                    println!("{} E-needs-mcve {} months old", issue.url, months_old,);
                }
            },
            || {},
        )
        .await;

    Ok(())
}

#[derive(PartialEq, PartialOrd, Ord, Eq, Debug)]
pub enum Conclusion {
    /// The issue never had the `E-needs-mcve` label.
    NeverLabeledNeedsMcve,

    /// Was labeled `E-needs-mcve` at the given date
    LabeledNeedsMcveAt(DateTime<FixedOffset>),

    /// The `E-needs-mcve` was resolved after the given number of weeks since it
    /// was added. "Resolved" means either that the label was removed or that
    /// the issue was closed.
    NeedsMcveResolvedAfterWeeks(i64),
}

pub fn get_e_needs_mcve_label_age(issue: &IssueWithTimelineItems) -> anyhow::Result<Duration> {
    let mut last_labeled_at = None;

    for timeline_item in &issue.timeline_items {
        if let TimelineItem::LabeledEvent { label, created_at } = timeline_item {
            if *label == Label::NeedsMcve {
                last_labeled_at = Some(*created_at);
            }
        }
    }

    let now = chrono::Utc::now();
    let duration =
        now.signed_duration_since(last_labeled_at.expect("only labeled issues queried for"));
    Ok(duration)
}
