use chrono::Duration;
use clap::Parser;
use tracing_subscriber::FmtSubscriber;

use rust_issue_stats::*;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,

    #[arg(long, default_value = "12")]
    label_months_considered_old: i64,

    #[arg(long, default_value = "36")]
    last_comment_months_considered_old: i64,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    // Enable like this: `RUST_LOG=rust_issue_stats=warn cargo run`
    tracing::subscriber::set_global_default(
        FmtSubscriber::builder()
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .finish(),
    )?;

    let github = GitHub::new();

    let variables = serde_json::json!({
        "page_size": args.page_size,
        "states": ["OPEN"],
        "item_types": ["LABELED_EVENT", "UNLABELED_EVENT", "ISSUE_COMMENT"],
        "filterBy": {
            "labels": ["E-needs-mcve"]
        }
    });
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let (label_age, comment_age) = get_e_needs_mcve_label_age(issue).unwrap();
                let label_age_months = label_age.to_months();
                let comment_age_months = comment_age.to_months();
                if label_age_months > args.label_months_considered_old
                    && comment_age_months > args.last_comment_months_considered_old
                {
                    println!(
                        "{} E-needs-mcve {} months old, last comment {} months ago",
                        issue.url, label_age_months, comment_age_months
                    );
                }
            },
            || {},
        )
        .await;

    Ok(())
}

trait ToMonths {
    fn to_months(&self) -> i64;
}

impl ToMonths for Duration {
    fn to_months(&self) -> i64 {
        let days = self.num_days();

        days / 30
    }
}

pub fn get_e_needs_mcve_label_age(
    issue: &IssueWithTimelineItems,
) -> anyhow::Result<(Duration, Duration)> {
    let mut last_labeled_at = None;
    let mut last_commented_at = None;

    for timeline_item in &issue.timeline_items {
        if let TimelineItem::LabeledEvent { label, created_at } = timeline_item {
            if *label == Label::NeedsMcve {
                last_labeled_at = Some(*created_at);
            }
        }
        if let TimelineItem::IssueComment { created_at, .. } = timeline_item {
            last_commented_at = Some(*created_at);
        }
    }

    let now = chrono::Utc::now();
    let label_age =
        now.signed_duration_since(last_labeled_at.expect("only labeled issues queried for"));
    let last_comment_age = now.signed_duration_since(last_commented_at.unwrap_or(issue.created_at));
    Ok((label_age, last_comment_age))
}
