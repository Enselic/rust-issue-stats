use chrono::{DateTime, FixedOffset};
use clap::Parser;
use tracing_subscriber::FmtSubscriber;

use rust_issue_stats::*;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,

    #[arg(long, default_value = "52")]
    weeks_considered_old: i64,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    // Enable like this: `RUST_LOG=rust_issue_stats=warn cargo run`
    tracing::subscriber::set_global_default(
        FmtSubscriber::builder()
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .finish(),
    )?;

    let github = GitHub::new();

    let variables = serde_json::json!({
        "page_size": args.page_size,
        "states": ["OPEN"],
        "filterBy": {
            "labels": ["E-needs-mcve"]
        }
    });
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let age_in_weeks = get_e_needs_mcve_label_age_in_weeks(issue).unwrap();
                if age_in_weeks > args.weeks_considered_old {
                    println!(
                        "{} weeks since {} was labelled E-needs-mcve",
                        age_in_weeks, issue.url
                    );
                }
            },
            || {},
        )
        .await;

    Ok(())
}

#[derive(PartialEq, PartialOrd, Ord, Eq, Debug)]
pub enum Conclusion {
    /// The issue never had the `E-needs-mcve` label.
    NeverLabeledNeedsMcve,

    /// Was labeled `E-needs-mcve` at the given date
    LabeledNeedsMcveAt(DateTime<FixedOffset>),

    /// The `E-needs-mcve` was resolved after the given number of weeks since it
    /// was added. "Resolved" means either that the label was removed or that
    /// the issue was closed.
    NeedsMcveResolvedAfterWeeks(i64),
}

pub fn get_e_needs_mcve_label_age_in_weeks(issue: &IssueWithTimelineItems) -> anyhow::Result<i64> {
    let mut last_labeled_at = None;

    for timeline_item in &issue.timeline_items {
        if let TimelineItem::LabeledEvent { label, created_at } = timeline_item {
            if *label == Label::NeedsMcve {
                last_labeled_at = Some(*created_at);
            }
        }
    }

    let now = chrono::Utc::now();
    let age = now
        .signed_duration_since(last_labeled_at.expect("only labeled issues queried for"))
        .num_weeks();
    Ok(age)
}
