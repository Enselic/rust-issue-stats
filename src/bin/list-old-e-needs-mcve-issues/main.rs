use chrono::{DateTime, FixedOffset};
use clap::Parser;
use std::cell::RefCell;
use std::fmt::Display;
use std::io::Write;
use std::path::PathBuf;
use tracing_subscriber::FmtSubscriber;

use rust_issue_stats::*;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    // Enable like this: `RUST_LOG=rust_issue_stats=warn cargo run`
    tracing::subscriber::set_global_default(
        FmtSubscriber::builder()
            .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
            .finish(),
    )?;


    let github = GitHub::new();

    let variables = serde_json::json!({
        "page_size": args.page_size,
    });
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let age_in_weeks = get_e_needs_mcve_label_age_in_weeks(issue).unwrap();
                if age_in_weeks > 52 {
                    println!("{issue} => {conclusion}").unwrap();
                }
            },
            || {},
        )
        .await;

    Ok(())
}

#[derive(PartialEq, PartialOrd, Ord, Eq, Debug)]
pub enum Conclusion {
    /// The issue never had the `E-needs-mcve` label.
    NeverLabeledNeedsMcve,

    /// Was labeled `E-needs-mcve` at the given date
    LabeledNeedsMcveAt(DateTime<FixedOffset>),

    /// The `E-needs-mcve` was resolved after the given number of weeks since it
    /// was added. "Resolved" means either that the label was removed or that
    /// the issue was closed.
    NeedsMcveResolvedAfterWeeks(i64),
}

pub fn get_e_needs_mcve_label_age_in_weeks(issue: &IssueWithTimelineItems) -> anyhow::Result<usize> {
    let mut state = IssueState::NeverLabeledNeedsMcve;

    for timeline_item in &issue.timeline_items {
        match state {
            IssueState::NeverLabeledNeedsMcve => {
                if let TimelineItem::LabeledEvent { label, created_at } = timeline_item {
                    if *label == Label::NeedsMcve {
                        state = IssueState::LabeledNeedsMcveDate(*created_at);
                    }
                }
            }
            IssueState::LabeledNeedsMcveDate(date) => {
                let resolved =
                    if let TimelineItem::UnlabeledEvent { label, created_at } = timeline_item {
                        if *label == Label::NeedsMcve {
                            Some(created_at)
                        } else {
                            None
                        }
                    } else if let TimelineItem::ClosedEvent { created_at } = timeline_item {
                        Some(created_at)
                    } else {
                        None
                    };

                if let Some(resolved) = resolved {
                    let duration = resolved.signed_duration_since(date);
                    return Ok(Conclusion::NeedsMcveResolvedAfterWeeks(
                        duration.num_weeks(),
                    ));
                }
            }
        }
    }

    Ok(state.into_conclusion())
}

impl Conclusion {
    pub fn ever_labeled_needs_mcve(&self) -> bool {
        match self {
            Conclusion::NeverLabeledNeedsMcve => false,
            Conclusion::NeedsMcveResolvedAfterWeeks(_) => true,
            Conclusion::LabeledNeedsMcveAt(_) => true,
        }
    }
}

impl Display for Conclusion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Conclusion::NeverLabeledNeedsMcve => f.write_str("Never labeled E-needs-mcve"),
            Conclusion::LabeledNeedsMcveAt(date) => {
                write!(
                    f,
                    "Labeled E-needs-mcve at {} but never resolved",
                    date.format("%Y-%m-%d")
                )
            }
            Conclusion::NeedsMcveResolvedAfterWeeks(weeks) => {
                write!(f, "Resolved E-needs-mcve after {} weeks", weeks)
            }
        }
    }
}

enum IssueState {
    NeverLabeledNeedsMcve,
    LabeledNeedsMcveDate(DateTime<FixedOffset>),
}

impl IssueState {
    fn into_conclusion(self) -> Conclusion {
        match self {
            IssueState::NeverLabeledNeedsMcve => Conclusion::NeverLabeledNeedsMcve,
            IssueState::LabeledNeedsMcveDate(date) => Conclusion::LabeledNeedsMcveAt(date),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use super::*;

    #[test]
    fn test_not_applicable() {
        let issue = IssueWithTimelineItems {
            number: 42,
            title: "Never labeled E-needs-mcve".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![TimelineItem::LabeledEvent {
                label: Label::Other("foo".to_string()),
                created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            }],
        };

        assert_eq!(
            get_e_needs_mcve_label_age_in_weeks(&issue).unwrap(),
            Conclusion::NeverLabeledNeedsMcve
        )
    }

    #[test]
    fn test_never_resolved() {
        let issue = IssueWithTimelineItems {
            number: 42,
            title: "Labeled E-needs-mcve but never resolved".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![TimelineItem::LabeledEvent {
                label: Label::NeedsMcve,
                created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            }],
        };

        assert_eq!(
            get_e_needs_mcve_label_age_in_weeks(&issue).unwrap(),
            Conclusion::LabeledNeedsMcveAt(
                DateTime::parse_from_rfc3339("2020-01-01T00:00:00Z").unwrap()
            )
        );
    }

    #[test]
    fn test_resolved_via_unlabeling() {
        let issue = IssueWithTimelineItems {
            number: 42,
            title: "Labeled E-needs-mcve then unlabeled".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![
                TimelineItem::LabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
                },
                TimelineItem::UnlabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-08T00:00:00Z").unwrap(),
                },
            ],
        };

        assert_eq!(
            get_e_needs_mcve_label_age_in_weeks(&issue).unwrap(),
            Conclusion::NeedsMcveResolvedAfterWeeks(1)
        );
    }

    #[test]
    fn test_resolved_via_close() {
        let issue = IssueWithTimelineItems {
            number: 42,
            title: "Labeled E-needs-mcve but never resolved".to_string(),
            created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
            timeline_items: vec![
                TimelineItem::LabeledEvent {
                    label: Label::NeedsMcve,
                    created_at: DateTime::from_str("2020-01-01T00:00:00Z").unwrap(),
                },
                TimelineItem::ClosedEvent {
                    created_at: DateTime::from_str("2020-01-15T00:00:00Z").unwrap(),
                },
            ],
        };

        assert_eq!(
            get_e_needs_mcve_label_age_in_weeks(&issue).unwrap(),
            Conclusion::NeedsMcveResolvedAfterWeeks(2)
        );
    }
}
