//! Run this to update `github_schema.graphql`:
//!
//! ```sh
//! curl -L https://docs.github.com/public/schema.docs.graphql -o schemas/github_schema.graphql
//! ```

use chrono::Duration;
use clap::Parser;
use graphql_client::GraphQLQuery;

use rust_issue_stats::*;

type URI = String;

#[derive(GraphQLQuery)]
#[graphql(
    schema_path = "schemas/github_schema.graphql",
    query_path = "issues_query.graphql",
    variables_derives = "Clone, Debug",
    response_derives = "Clone, Debug"
)]
pub struct IssuesQuery;

#[derive(clap::Parser, Debug)]
pub struct Args {
    #[arg(long, default_value = "10")]
    page_size: u16,

    #[arg(long, default_value = "2")]
    pages: usize,

    #[arg(long, default_value = "36")]
    label_months_considered_old: i64,

    #[arg(long, default_value = "36")]
    last_comment_months_considered_old: i64,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    log_init()?;

    let args = Args::parse();

    let github = GitHub::new();

    let variables = issues_query::Variables {
        page_size: args.page_size,
        states: ["OPEN"],
        timelineItemTypes: ["LABELED_EVENT", "UNLABELED_EVENT", "ISSUE_COMMENT"],
        filterBy: IssuesQueryFilterBy {
            labels: ["E-needs-mcve"],
        },
    };
    github
        .for_issues_with_timeline(
            variables,
            args.pages,
            |issue| {
                let (label_age, comment_age) = get_ages(issue).unwrap();
                let label_age_months = label_age.to_months();
                let comment_age_months = comment_age.to_months();

                let old_enough = label_age_months > args.label_months_considered_old
                    && comment_age_months > args.last_comment_months_considered_old;

                let labeled_triaged = issue
                    .labels
                    .nodes
                    .iter()
                    .any(|label| label.name.to_lowercase().contains("triaged"));

                if old_enough && !labeled_triaged {
                    println!(
                        "{} E-needs-mcve {} months old, last comment {} months ago",
                        issue.url, label_age_months, comment_age_months
                    );
                }
            },
            || {},
        )
        .await;

    Ok(())
}

trait ToMonths {
    fn to_months(&self) -> i64;
}

impl ToMonths for Duration {
    fn to_months(&self) -> i64 {
        let days = self.num_days();

        days / 30
    }
}

pub fn get_ages(issue: &IssueWithTimelineItems) -> anyhow::Result<(Duration, Duration)> {
    let mut last_labeled_at = None;
    let mut last_commented_at = None;

    for timeline_item in &issue.timeline_items {
        if let TimelineItem::LabeledEvent {
            label: Label { name },
            created_at,
        } = timeline_item
        {
            if name == E_NEEDS_MCVE {
                last_labeled_at = Some(*created_at);
            }
        }
        if let TimelineItem::IssueComment { created_at, .. } = timeline_item {
            last_commented_at = Some(*created_at);
        }
    }

    let now = chrono::Utc::now();
    let label_age =
        now.signed_duration_since(last_labeled_at.expect("only labeled issues queried for"));
    let last_comment_age = now.signed_duration_since(last_commented_at.unwrap_or(issue.created_at));
    Ok((label_age, last_comment_age))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let octocrab = octocrab::Octocrab::builder()
        .personal_token(std::env::var("GITHUB_TOKEN").unwrap())
        .build()?;

    let mut variables = issues_query::Variables {
        owner: "XAMPPRocky".to_string(),
        name: "octocrab".to_string(),
        page_size: 5,
        before: None,
    };

    let pages_to_show = 3;
    let mut page = 1;
    loop {
        if page > pages_to_show {
            break;
        }

        let response: octocrab::Result<graphql_client::Response<issues_query::ResponseData>> =
            octocrab
                .graphql(&IssuesQuery::build_query(variables.clone()))
                .await;

        match response {
            Ok(response) => {
                println!("Page {page}:");
                let issues = &response
                    .data
                    .as_ref()
                    .unwrap()
                    .repository
                    .as_ref()
                    .unwrap()
                    .issues;
                print_issues(issues);
                if !update_page_info(&mut variables, issues) {
                    break;
                }
            }
            Err(error) => {
                println!("{error:#?}");
                break;
            }
        }

        page += 1;
    }

    Ok(())
}
